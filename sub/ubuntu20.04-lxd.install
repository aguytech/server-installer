#!/bin/bash
#
# write by Aguy

_echoT "\n==========================================  ${S_RELEASE}-${_PART}"

grep -q "^# ${_PART#++}$" ${S_FILE_INSTALL_CONF} || echo "# ${_PART}" >> ${S_FILE_INSTALL_CONF}

########################  REQUIRED

path_install_conf=${S_PATH_INSTALL_CONF/-desktop/}
file_rsyslog_client_lxd=${path_install_conf}/rsyslog/client-lxd.conf
file_logrotate_client_lxd=${path_install_conf}/logrotate/client-lxd

_echot "------------------ required files"
_require ${file_rsyslog_client_lxd} ${file_logrotate_client_lxd}

########################  DATA

_echot "------------------  data"

lxd_version_now=$(snap list|awk '/^lxd/ {print $2}')

[ -z ${_LXD_DHCP_MIN+x} ] && { anstmp="20"; _askno "Give minimal range IP for DHCP container (${anstmp})"; _LXD_DHCP_MIN="${_ANSWER:-$anstmp}"; }
_confset _LXD_DHCP_MIN "${_LXD_DHCP_MIN}"

[ -z ${_LXD_DHCP_MAX+x} ] && { anstmp="254"; _askno "Give maximal range IP for DHCP container (${anstmp})"; _LXD_DHCP_MAX="${_ANSWER:-$anstmp}"; }
_confset _LXD_DHCP_MAX "${_LXD_DHCP_MAX}"

# root path of lxd
_LXD_PATH_ROOT=/var/snap/lxd; _confset _LXD_PATH_ROOT "${_LXD_PATH_ROOT}"
# root path of storage pools for
_LXD_PATH_SP=storage-pools; _confset _LXD_PATH_SP "${_LXD_PATH_SP}"
# path for containers
_LXD_PATH_CT=containers; _confset _LXD_PATH_CT "${_LXD_PATH_CT}"
# path for containers images
_LXD_PATH_IMAGE=images; _confset _LXD_PATH_IMAGE "${_LXD_PATH_IMAGE}"
# path for containers snapshots
_LXD_PATH_SNAPSHOT=snapshots; _confset _LXD_PATH_SNAPSHOT "${_LXD_PATH_SNAPSHOT}"
# path for export
_LXD_PATH_EXPORT=export; _confset _LXD_PATH_EXPORT "${_LXD_PATH_EXPORT}"
# port for remote connection
_LXD_PORT=8443; _confset _LXD_PORT "${_LXD_PORT}"
# uid for shared path
_LXD_UID=1000000; _confset _LXD_UID "${_LXD_UID}"

########################  CONFIGURATION

# load configuration file
. ${S_FILE_INSTALL_CONF}

########################  STORAGE

if [ "${_DEV_DRIVER}" = zfs ] && ! zfs list -r ${_ZFS_ROOT}|grep -q ${_ZFS_ROOT}/lxd; then

	_echot "------------------  snap lxd version"
	_echo ${lxd_version_now}

	if snap list|grep -q ^lxd; then
		_echot "------------------  snap remove lxd"
		snap remove --purge lxd
	fi
	path=${_LXD_PATH_ROOT}
	_echot "------------------  zfs ${path}"
	[ -d ${path} ] && mv ${path} ${path}.${_SDATE}
	_eval zfs create -o mountpoint=${path} -o compression=lz4 ${_ZFS_ROOT}/lxd
fi

########################  INSTALL

_echot "------------------  install"
_evalr apt install -y jq acl # criu lxd-tools

# core20
if ! snap list|grep -q ^core20; then
	if snap list|grep -q ^lxd; then
		_echot "------------------  snap remove lxd"
		_evalr snap remove lxd
	fi
	if snap list|grep -q ^core18; then
		_echot "------------------  snap remove core18"
		_evalr snap remove core18
	fi
	_echot "------------------  snap install core20"
	_evalr snap install core20
fi

# lxd
if snap list|grep -q ^lxd; then
	_echot "------------------  snap refresh lxd"
	_evalr snap refresh --channel=latest lxd
else
	_echot "------------------  snap install lxd"
	_evalr snap install --channel=latest lxd
fi
_evalr snap start lxd --enable

########################  RIGHTS

path=${_LXD_PATH_ROOT}/common/lxd
_echot "------------------  link ${path} to /lxd"
[ -h /lxd ] || _evalr ln -s ${path} /lxd

path=${S_HOST_PATH_SHARE}
_echot "------------------  rights ${path}"
_evalr setfacl -Rm u:${_LXD_UID}:rwx ${path}
_evalr setfacl -Rm d:u:${_LXD_UID}:rwx ${path}
_evalr chown -R ${_LXD_UID}:${_LXD_UID} ${path}

########################  CLEAN STORAGE

if [ "${_DEV_DRIVER}" = zfs ]; then
	for path in `_evalr zfs list -d 1 -o name -H ${_ZFS_ROOT}${S_HOST_PATH_SP}|grep -v ^${_ZFS_ROOT}${S_HOST_PATH_SP}$`; do
		_echot "------------------  backup ${path} to ${path}.${_SDATE}"
		_evalr zfs rename ${path} ${path}.${_SDATE}
	done
elif [ "${_DEV_DRIVER}" = btrfs ]; then
	for path in `ls ${S_HOST_PATH_SP}`; do
		_echot "------------------  backup ${path} to ${path}.${_SDATE}"
		_evalr mv ${S_HOST_PATH_SP}/${path} ${S_HOST_PATH_SP}/${path}.${_SDATE}
	done
else
	_exite "This part have to be implemented"
fi

########################  INIT

_echot "------------------  lxd init"

if [ "${_DEV_DRIVER}" = zfs ]; then
	_echoA "Use this settings:"
	_echoa "- Create a new ZFS pool ?: no"
	_echoa "- Name of the existing ZFS pool or dataset: ${_ZFS_ROOT}${S_HOST_PATH_SP}/default"
elif [ "${_DEV_DRIVER}" = btrfs ]; then
	_echoA "Use this settings:"
	_echoa "- Create a new BTRFS pool?: no"
	_echoa "- Name of the existing BTRFS pool or dataset: ${S_HOST_PATH_SP}/default"
else
	_exite "This part have to be implemented"
fi

_evalr lxd init || _exite "unable to initalize lxd"

########################  DNS

str=" ovh home "
if [ "${str/ ${S_SERVER_TYPE} /}" != "${str}" ]; then

	# get : s_inet s_cidr s_base
	eval ${S_HOST_VM_ETH[default]}

	_echot "------------------  dns ovh"

	file=/etc/resolv.conf
	_keepcpts ${file}
	if ! grep -q ${s_inet} ${file}; then
		_evalr "sed -i 's|^|#|' ${file}"
		sudo sh -c "echo 'nameserver 127.0.0.53\noptions edns0 trust-ad\nsearch lxd' > ${file}"
	 fi

	_echot "------------------  dns home"

	service=lxd-dns-${s_inet}
	file=/etc/systemd/system/${service}.service
	sudo sh -c "echo '[Unit]
Description=LXD per-link DNS configuration for ${s_inet}
BindsTo=sys-subsystem-net-devices-${s_inet}.device
After=sys-subsystem-net-devices-${s_inet}.device

[Service]
Type=oneshot
ExecStart=/usr/bin/resolvectl dns ${s_inet} ${s_cidr%/*}
ExecStart=/usr/bin/resolvectl domain ${s_inet} '~lxd'

[Install]
WantedBy=sys-subsystem-net-devices-${s_inet}.device
' > ${file}"

	_evalr systemctl daemon-reload
	_evalr systemctl -q enable --now ${service}
	_evalr resolvectl status ${s_inet}

fi

########################  STORAGE

name="stock"
_echot "------------------  storage ${name}"

if ! [ "`lxc storage list -f json|jq -r '.[] | select(.name == "'${name}'").name'`" ]; then
	if [ "${_DEV_DRIVER}" = zfs ]; then
		_eval lxc storage create ${name} zfs source=${_ZFS_ROOT}${S_HOST_PATH_SP}/${name}
	elif [ "${_DEV_DRIVER}" = btrfs ]; then
		_eval lxc storage create ${name} btrfs source=${S_HOST_PATH_SP}/${name}
	else
		_exite "This part have to be implemented"
	fi
fi

########################  NETWORK

_echot "------------------  network 'default'"

# get : s_inet s_cidr s_base
eval ${S_HOST_VM_ETH[default]}

_echot "------------------  network ${s_inet}"

if ! [ "`lxc network list -f json|jq -r '.[] | select(.name == "'${s_inet}'").name'`" ]; then
	_eval lxc network create ${s_inet}
fi
_eval lxc network set ${s_inet} ipv4.address=${s_cidr} ipv4.dhcp.ranges=${s_cidr%.*}.${_LXD_DHCP_MIN}-${s_cidr%.*}.${_LXD_DHCP_MAX} ipv4.nat=true dns.mode=managed dns.domain=lxd dns.mode=managed

_echot "------------------  network 'stock'"
# get : s_inet s_cidr s_base
eval ${S_HOST_VM_ETH[stock]}

_echot "------------------  network ${s_inet}"
if ! [ "`lxc network list -f json|jq -r '.[] | select(.name == "'${s_inet}'").name'`" ]; then
	_eval lxc network create "${s_inet}"
fi
_eval lxc network set ${s_inet} ipv4.address=${s_cidr} ipv4.dhcp.ranges=${s_cidr%.*}.${_LXD_DHCP_MIN}-${s_cidr%.*}.${_LXD_DHCP_MAX} ipv4.nat=true dns.mode=managed dns.domain=lxd1 dns.mode=managed

########################  PROFILE

profile="stock"
_echot "------------------  profiles ${profile}"
lxc profile list -f csv|grep -q "^${profile}," && _evalr lxc profile rename ${profile} ${profile}.${_SDATE}
_eval lxc profile create ${profile}
_eval lxc profile device add ${profile} root disk pool=stock path=/
_eval lxc network attach-profile lxdbr1 ${profile} eth0

########################  RSYSLOG

_echot "------------------  path log lxd"
path=${S_PATH_LOG}/lxd
[ -d ${path} ] || _evalr mkdir -p ${path}
grep -q syslog /etc/passwd && _evalr chown syslog ${path}

_echot "------------------  rsyslog client-lxd"
file=/etc/rsyslog.d/76-${file_rsyslog_client_lxd##*/}
_evalr cp -a ${file_rsyslog_client_lxd} ${file}
_var_replace ${file} rsyslog

########################  LOGROTATE

_echot "------------------  logrotate client-lxd"
file=/etc/logrotate.d/${file_logrotate_client_lxd##*/}
_evalr cp -a ${file_logrotate_client_lxd} ${file}
_var_replace ${file} logrotate
_evalr chmod g-w /etc/logrotate.d/*
_service restart logrotate

_echot "------------------  logrotate restart"
_service restart logrotate

########################  CONTAINERS

_echot "------------------ lxd containers"
_echoA "You need to launch following command to build containers:"
_echoa `ls ${_PATH_BASE}/lxd-*`

########################  REBOOT

_echot "------------------ reboot"
_echoW "You have to reboot before continuing"

########################  END

_echoT "===================== ${_PART} end"
_partadd ${_PART#++} ${S_FILE_INSTALL_DONE}
