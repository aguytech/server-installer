#!/bin/bash
#
# write by Aguy

_echoT "\n==========================================  ${S_RELEASE}-${_PART}"

########################  DATA

_echoT "----------  data"

[ -z ${_LXD_DHCP_MIN+x} ] && anstmp="20" && _askno "Give minimal range IP for DHCP container (${anstmp})" && _LXD_DHCP_MIN="${_ANSWER:-$anstmp}" && _confset _LXD_DHCP_MIN "${_LXD_DHCP_MIN}"

[ -z ${_LXD_DHCP_MAX+x} ] && anstmp="254" && _askno "Give maximal range IP for DHCP container (${anstmp})" && _LXD_DHCP_MAX="${_ANSWER:-$anstmp}" && _confset _LXD_DHCP_MAX "${_LXD_DHCP_MAX}"


# root path of lxd
_LXD_PATH_ROOT=/var/snap/lxd/common/lxd && _confset _LXD_PATH_ROOT "${_LXD_PATH_ROOT}"
# root path of storage pools for
_LXD_PATH_SP=storage-pools && _confset _LXD_PATH_SP "${_LXD_PATH_SP}"
# path for containers
_LXD_PATH_CT=containers && _confset _LXD_PATH_CT "${_LXD_PATH_CT}"
# path for containers images
_LXD_PATH_IMAGE=images && _confset _LXD_PATH_IMAGE "${_LXD_PATH_IMAGE}"
# path for containers snapshots
_LXD_PATH_SNAPSHOT=snapshots && _confset _LXD_PATH_SNAPSHOT "${_LXD_PATH_SNAPSHOT}"
# path for export
_LXD_PATH_EXPORT=export && _confset _LXD_PATH_EXPORT "${_LXD_PATH_EXPORT}"
# port for remote connection
_LXD_PORT=8443 && _confset _LXD_PORT "${_LXD_PORT}"


########################  INSTALL

_echoT "----------  install"

_evalr apt install -y jq acl # criu lxd-tools

_echoT "----------  snap"

if snap list|grep -q '^lxd '; then
	_eval snap remove lxd
	_eval snap refresh
	if snap list|grep -q '^core18 '; then
		_eval snap install core20
		_eval snap remove core18
	fi
fi
_eval snap refresh
_eval snap install lxd


########################  RIGHTS

path=/var/snap/lxd/common/lxd
_echoT "----------  link ${path} to /lxd"

link="/lxd"
[ -h ${link} ] || _evalr ln -s ${path} ${link}

path="${S_HOST_PATH_SHARE}"
_echoT "----------  rights ${path}"
[ "${S_STORAGE_DRIVER}" = zfs ] && id=1000000 || id=100000
_evalr setfacl -Rm u:${id}:rwx "${path}"
_evalr setfacl -Rm d:u:${id}:rwx "${path}"
_evalr chown ${id}:${id} -R "${path}"


########################  CLEAN STORAGE

if [ "${S_STORAGE_DRIVER}" = zfs ]; then
	for path in `_evalr zfs list -d 1 -o name -H ${_ZFS_ROOT}${S_HOST_PATH_SP}|grep -v ^${_ZFS_ROOT}${S_HOST_PATH_SP}$`; do
		_echoI "backup ${path} to ${path}.${_SDATE}"
		_evalr zfs rename ${path} ${path}.${_SDATE}
	done
elif [ "${S_STORAGE_DRIVER}" = btrfs ]; then
	for path in `ls ${S_HOST_PATH_SP}`; do
		_echoI "backup ${path} to ${path}.${_SDATE}"
		_evalr mv ${S_HOST_PATH_SP}/${path} ${S_HOST_PATH_SP}/${path}.${_SDATE}
	done
else
	_exite "This part have to be implemented"
fi


########################  INIT

_echoT "----------  lxd init"

if [ "${S_STORAGE_DRIVER}" = zfs ]; then
	_echoI "Use this settings:"
	_echoW "- Create a new ZFS pool ?: no"
	_echoW "- Name of the existing ZFS pool or dataset: ${_ZFS_ROOT}${S_HOST_PATH_SP}/default"
elif [ "${S_STORAGE_DRIVER}" = btrfs ]; then
	_echoI "Use this settings:"
	_echoW "- Create a new BTRFS pool ?: no"
	_echoW "- Name of the existing BTRFS pool or dataset: ${S_HOST_PATH_SP}/default"
else
	_exite "This part have to be implemented"
fi

_eval lxd init


########################  DNS

str=" ovh home "
if [ "${str/ ${S_SERVER_TYPE} /}" != "${str}" ]; then

	# get : s_inet s_cidr s_base
	eval ${S_HOST_VM_ETH[default]}

	_echoT "----------  dns ovh"

	file=/etc/resolv.conf
	_keepcpts ${file}
	if ! grep -q ${s_inet} ${file}; then
		_evalr "sed -i 's|^|#|' ${file}"
	 	echo -e 'nameserver 127.0.0.53\noptions edns0 trust-ad\nsearch lxd' | _evalr tee ${file}
	 fi

	_echoT "----------  dns home"

	service=lxd-dns-${s_inet}
	file=/etc/systemd/system/${service}.service
	cat > ${file} <<EOF
[Unit]
Description=LXD per-link DNS configuration for ${s_inet}
BindsTo=sys-subsystem-net-devices-${s_inet}.device
After=sys-subsystem-net-devices-${s_inet}.device

[Service]
Type=oneshot
ExecStart=/usr/bin/resolvectl dns ${s_inet} ${s_cidr%/*}
ExecStart=/usr/bin/resolvectl domain ${s_inet} '~lxd'

[Install]
WantedBy=sys-subsystem-net-devices-${s_inet}.device
EOF

	_evalr systemctl daemon-reload
	_evalr systemctl enable --now ${service}
	_evalr resolvectl status ${s_inet}

fi


########################  STORAGE

name="stock"
_echoT "----------  storage ${name}"

if ! [ "`lxc storage list -f json|jq -r '.[] | select(.name == "'${name}'").name'`" ]; then
	if [ "${S_STORAGE_DRIVER}" = zfs ]; then
		_eval lxc storage create ${name} zfs source=${_ZFS_ROOT}${S_HOST_PATH_SP}/${name}
	elif [ "${S_STORAGE_DRIVER}" = btrfs ]; then
		_eval lxc storage create ${name} btrfs source=${S_HOST_PATH_SP}/${name}
	else
		_exite "This part have to be implemented"
	fi
fi


########################  NETWORK

_echoT "----------  network 'default'"

# get : s_inet s_cidr s_base
eval ${S_HOST_VM_ETH[default]}

_echoT "----------  network ${s_inet}"

if ! [ "`lxc network list -f json|jq -r '.[] | select(.name == "'${s_inet}'").name'`" ]; then
	_eval lxc network create ${s_inet}
fi
_eval lxc network set ${s_inet} ipv4.address=${s_cidr} ipv4.dhcp.ranges=${s_cidr%.*}.${_LXD_DHCP_MIN}-${s_cidr%.*}.${_LXD_DHCP_MAX} ipv4.nat=true dns.mode=managed dns.domain=lxd dns.mode=managed


_echoT "----------  network 'stock'"

# get : s_inet s_cidr s_base
eval ${S_HOST_VM_ETH[stock]}

_echoT "----------  network ${s_inet}"

if ! [ "`lxc network list -f json|jq -r '.[] | select(.name == "'${s_inet}'").name'`" ]; then
	_eval lxc network create "${s_inet}"
fi
_eval lxc network set ${s_inet} ipv4.address=${s_cidr} ipv4.dhcp.ranges=${s_cidr%.*}.${_LXD_DHCP_MIN}-${s_cidr%.*}.${_LXD_DHCP_MAX} ipv4.nat=true dns.mode=managed dns.domain=lxd1 dns.mode=managed


########################  PROFILE

profile="stock"
_echoT "----------  profiles ${profile}"

lxc profile list -f csv|grep -q "^${profile}," && lxc profile rename ${profile} ${profile}.${_SDATE}
_eval lxc profile create ${profile}
_eval lxc profile device add ${profile} root disk pool=stock path=/
_eval lxc network attach-profile lxdbr1 ${profile} eth0


_echoT "----------  lxc container"

_echoI "To install and configure container use:"
_echoI "$(ls -1 ${S_PATH_INSTALL/-desktop/}/lxd-*)"


########################  REBOOT

_echoT "---------- reboot"
_echoI "You have to reboot before continuing"


########################  END

_echoT "===================== ${_PART} end"
_eval "_partadd ${_PART} ${S_FILE_INSTALL_DONE}"
