#!/bin/bash
#
# write by Aguy

_echoT "\n==========================================  ${_INSTALL}-${_PART}"

grep -q "^# ${_PART#++}$" ${S_FILE_INSTALL_CONF} || echo  "# ${_PART}" >> ${S_FILE_INSTALL_CONF}

########################  REQUIRED

_echoT "------------------ required vm image"
lxc image list -f csv -c l | grep -q ^${_CT_NAME_COM}$ || _exite "Unable to find image container: '${_CT_NAME_COM}'"

_echoT "------------------ required vm"
lxc list -f csv -c n | grep -q ^${S_SERVICE[log]}$ || _exite "Unable to find container: '${S_SERVICE[log]}'"

file_rsyslog_host=${S_PATH_INSTALL_CONF}/rsyslog/host-redis.conf
file_rsyslog_client=${S_PATH_INSTALL_CONF}/rsyslog/client-redis.conf
file_logrotate_host=${S_PATH_INSTALL_CONF}/logrotate/host-redis
file_logrotate_client=${S_PATH_INSTALL_CONF}/logrotate/client-redis

_echoT "------------------ required files"
_require ${file_rsyslog_host} ${file_rsyslog_client} ${file_logrotate_host} ${file_logrotate_client}

########################  DATA

_echoT "------------------  data domain"

anstmp=rds-${S_DOMAIN_NAME//./-} && _askno "Base name of containers to build (${anstmp})"
ct_base="${_ANSWER:-$anstmp}"

anstmp=1 && _askno "Number of containers to build (${anstmp})"
ct_num="${_ANSWER:-$anstmp}"

_echoT "------------------  data"

[ -z ${_RDS_CLIENT+x} ] && anstmp=y && _askno "Install redis-client on Host (${anstmp})" && _RDS_CLIENT="${_ANSWER:-$anstmp}" && _confset _RDS_CLIENT "${_RDS_CLIENT}"

_echoT "------------------  data sysctl.conf"

[ -z ${_RDS_MAX_SYN_BACKLOG+x} ] && anstmp="${_MAX_SYN_BACKLOG}" && _askno "Set $(sysctl net.ipv4.tcp_max_syn_backlog) - (${anstmp})" && _RDS_MAX_SYN_BACKLOG="${_ANSWER:-$anstmp}" && _confset _RDS_MAX_SYN_BACKLOG "${_RDS_MAX_SYN_BACKLOG}"

[ -z ${_RDS_MAX_TW_BUCKETS+x} ] && anstmp="${_MAX_TW_BUCKETS}" && _askno "Set $(sysctl net.ipv4.tcp_max_tw_buckets) - (${anstmp})" && _RDS_MAX_TW_BUCKETS="${_ANSWER:-$anstmp}" && _confset _RDS_MAX_TW_BUCKETS "${_RDS_MAX_TW_BUCKETS}"

[ -z ${_RDS_FIN_TIMEOUT+x} ] && anstmp="${_FIN_TIMEOUT}" && _askno "Set $(sysctl net.ipv4.tcp_fin_timeout) - (${anstmp})" && _RDS_FIN_TIMEOUT="${_ANSWER:-$anstmp}" && _confset _RDS_FIN_TIMEOUT "${_RDS_FIN_TIMEOUT}"

[ -z ${_RDS_KEEPALIVE_TIME+x} ] && anstmp=240 && _askno "Set $(sysctl net.ipv4.tcp_keepalive_time) - (${anstmp})" && _RDS_KEEPALIVE_TIME="${_ANSWER:-$anstmp}" && _confset _RDS_KEEPALIVE_TIME "${_RDS_KEEPALIVE_TIME}"

[ -z ${_RDS_KEEPALIVE_INTVL+x} ] && anstmp=30 && _askno "Set $(sysctl net.ipv4.tcp_keepalive_intvl) - (${anstmp})" && _RDS_KEEPALIVE_INTVL="${_ANSWER:-$anstmp}" && _confset _RDS_KEEPALIVE_INTVL "${_RDS_KEEPALIVE_INTVL}"

[ -z ${_RDS_KEEPALIVE_PROBES+x} ] && anstmp=9 && _askno "Set $(sysctl net.ipv4.tcp_keepalive_probes) - (${anstmp})" && _RDS_KEEPALIVE_PROBES="${_ANSWER:-$anstmp}" && _confset _RDS_KEEPALIVE_PROBES "${_RDS_KEEPALIVE_PROBES}"

_echoT "------------------  data redis"

anstmp="$(( ${_RDS_MAX_SYN_BACKLOG} / 2 ))" && _askno "Value for 'tcp-backlog', if change adjust sysctl parameters... (${anstmp})"
_RDS_BACKLOG="${_ANSWER:-$anstmp}" && _confset _RDS_BACKLOG "${_RDS_BACKLOG}"

anstmp="$(( ${_APA_KEEPALIVE_TIME} + 60 ))" && _askno "Time to keep alive (sends acks) 'tcp-keepalive' (${anstmp})s"
_RDS_KEEPALIVE="${_ANSWER:-$anstmp}" && _confset _RDS_KEEPALIVE "${_RDS_KEEPALIVE}"

anstmp=3600 && _askno "Time to idle connection 'timeout' (${anstmp})s"
_RDS_TIMEOUT="${_ANSWER:-$anstmp}" && _confset _RDS_TIMEOUT "${_RDS_TIMEOUT}"

anstmp=16 && _askno "Number of max 'databases' (${anstmp})"
_RDS_DATABASES="${_ANSWER:-$anstmp}" && _confset _RDS_DATABASES "${_RDS_DATABASES}"

anstmp=512mb && _askno "Memory usage limit (${anstmp})"
_RDS_MEM_MAX="${_ANSWER:-$anstmp}" && _confset _RDS_MEM_MAX "${_RDS_MEM_MAX}"

_echoI "MAXMEMORY POLICY"
-echo "# allkeys-lru -> Evict any key using approximated LRU
# volatile-lfu -> Evict using approximated LFU, only keys with an expire set
# allkeys-lfu -> Evict any key using approximated LFU
# volatile-random -> Remove a random key having an expire set
# allkeys-random -> Remove a random key, any key
# volatile-ttl -> Remove the key with the nearest expire time (minor TTL)
# noeviction -> Don't evict anything, just return an error on write operations"
anstmp=volatile-ttl && _askno "Policy to remove keys when maxmemory is reached (${anstmp})"
_RDS_MEM_POL="${_ANSWER:-$anstmp}" && _confset _RDS_MEM_POL "${_RDS_MEM_POL}"

anstmp=notice && _askno "Give the log level 'loglevel': debug/verbose/notice/warning (${anstmp})"
_RDS_LOGLEVEL="${_ANSWER:-$anstmp}" && _confset _RDS_LOGLEVEL "${_RDS_LOGLEVEL}"

_CT_NAME=${ct_base}-1

########################  INIT

_echoT "------------------  init"

if lxc list -f csv -c n | grep -q ^${_CT_NAME}$; then
	lxc list -f csv -c n status=Running| grep -q ^${_CT_NAME}$ && _eval lxc stop ${_CT_NAME}
	_echoT "------------------ rename ${_CT_NAME} -> ${_CT_NAME}-${_SDATE}"
	_eval lxc rename ${_CT_NAME} ${_CT_NAME}-${_SDATE}
fi

_eval lxc init ${_CT_NAME_COM} ${_CT_NAME} -p default -p global

_echoT "------------------  ${_CT_NAME} start"
_eval lxc start ${_CT_NAME}

########################  METADATA

_echoT "------------------  metadata"
_lxc_meta_set ${_CT_NAME} profiles default global
_lxc_meta_add ${_CT_NAME} apps redis

########################  SYSCTL

_echoT "------------------  host conf sysctl.conf"
if grep -q vm.overcommit_memory ${_SYS_FILE}; then
	sed -i "/vm.overcommit_memory/ s|=.*|= 1|" >> ${_SYS_FILE}
else
	echo "vm.overcommit_memory = 1" >> ${_SYS_FILE}
fi

_echoT "------------------  conf sysctl.conf"
file=/etc/sysctl.d/20-lxd.conf
txt="# apache2 php-fpm
net.ipv4.tcp_max_syn_backlog = ${_RDS_MAX_SYN_BACKLOG}
net.ipv4.tcp_max_tw_buckets = ${_RDS_MAX_TW_BUCKETS}
net.ipv4.tcp_fin_timeout = ${_RDS_FIN_TIMEOUT}
net.ipv4.tcp_keepalive_time = ${_RDS_KEEPALIVE_TIME}
net.ipv4.tcp_keepalive_intvl = ${_RDS_KEEPALIVE_INTVL}
net.ipv4.tcp_keepalive_probes = ${_RDS_KEEPALIVE_PROBES}"
_lxc_exec ${_CT_NAME} "echo '${txt}' > ${file}"

########################  INSTALL

if [ "${_RDS_CLIENT}" = y ]; then
	_echoT "------------------  host install"
	_install redis-tools
fi

_echoT "------------------  install"
_lxc_exec ${_CT_NAME} "apk update"
_lxc_exec ${_CT_NAME} "apk add redis"

_echoT "------------------  service set"
service=redis
_lxc_exec ${_CT_NAME} "rc-update add ${service}"
_lxc_exec ${_CT_NAME} "rc-service ${service} start"

########################  CONF

_echoT "------------------  conf"
file=/etc/redis.conf
_lxc_exec ${_CT_NAME} "sed -i 's|^\(bind\) .*$|\1 * -::*|'  ${file}"
_lxc_exec ${_CT_NAME} "sed -i '/^logfile / s|^|#|'  ${file}"

cmds=; while read str val; do
	cmds+="sed -i 's|^#\?\s*\(${str}\) .*|\1 ${val}|' ${file}
"; done <<< "port  ${S_CACHE_PORT}
tcp-backlog  ${_RDS_BACKLOG}
timeout  ${_RDS_TIMEOUT}
tcp-keepalive  ${_RDS_KEEPALIVE}
maxmemory ${_RDS_MEM_MAX}
maxmemory-policy ${_RDS_MEM_POL}
databases  ${_RDS_DATABASES}
loglevel  ${_RDS_LOGLEVEL}
syslog-enabled  yes
syslog-ident  redis
syslog-facility  local7"
_lxc_exec ${_CT_NAME} "${cmds}"

_echoT "------------------  restart redis"
_lxc_exec ${_CT_NAME} "rc-service redis restart"

########################  RSYSLOG

_echoT "------------------  ${S_SERVICE[log]} host path"
path=${S_VM_PATH_LOG}/redis
_lxc_exec ${S_SERVICE[log]} "[ -d ${path} ] || mkdir -p ${path}"


_echoT "------------------  ${S_SERVICE[log]} host-redis"
file=/etc/rsyslog.d/${file_rsyslog_host##*/}
_eval lxc file push -q ${file_rsyslog_host} ${S_SERVICE[log]}${file}
_lxc_var_replace ${S_SERVICE[log]} ${file} rsyslog

_echoT "------------------  restart rsyslog ${S_SERVICE[log]}"
_lxc_exec ${S_SERVICE[log]} "rc-service rsyslog restart"

_echoT "------------------  ${S_SERVICE[log]} client path"
path=${S_PATH_LOG}/redis
_lxc_exec ${_CT_NAME} "[ -d ${path} ] || mkdir -p ${path}"
_lxc_exec ${_CT_NAME} "rm ${path}/redis.log 2>/dev/null"

_echoT "------------------  ${S_SERVICE[log]} client-redis"
file=/etc/rsyslog.d/${file_rsyslog_client##*/}
_eval lxc file push -q ${file_rsyslog_client} ${_CT_NAME}${file}
_lxc_var_replace ${_CT_NAME} ${file} rsyslog

_echoT "------------------  rsyslog restart ${_CT_NAME}"
_lxc_exec ${_CT_NAME} "rc-service rsyslog restart"

########################  LOGROTATE

_echoT "------------------  ${S_SERVICE[log]} logrotate"
file=/etc/logrotate.d/${file_logrotate_host##*/}
_eval lxc file push -q ${file_logrotate_host} ${S_SERVICE[log]}${file}
_lxc_var_replace ${S_SERVICE[log]} ${file} logrotate

_echoT "------------------  ${S_SERVICE[log]} crond restart"
_lxc_exec ${S_SERVICE[log]} "rc-service crond restart"


_echoT "------------------  ${_CT_NAME} logrotate"
file=/etc/logrotate.d/${file_logrotate_client##*/}
_eval lxc file push -q ${file_logrotate_client} ${_CT_NAME}${file}
_lxc_var_replace ${_CT_NAME} ${file} logrotate

_echoT "------------------  ${_CT_NAME} crond restart"
_lxc_exec ${_CT_NAME} "rc-service crond restart"

########################  CLEAN LOG

_echoT "------------------  ${_CT_NAME} log clean"
_lxc_exec ${_CT_NAME} "find ${S_PATH_LOG}/redis -name *.log -exec rm {} \;"

########################  TEST

_echoT "------------------  redis test access"
_echo "timeout 3 redis-cli -h ${_CT_NAME} ping"
_eval "timeout 3 redis-cli -h ${_CT_NAME} ping 2>/dev/null"

_echoI "\nTo do a benchmark, just type:" && sleep 0.1
_echo "redis-benchmark -h ${_CT_NAME} -p ${S_CACHE_PORT} -n 1000 -c 10 -k 1 -q"
_echo "redis-benchmark -h ${_CT_NAME} -p ${S_CACHE_PORT} -n 10000 -c 10 -k 1"
_echoI "\nTo see latency, just type:" && sleep 0.1
_echo "redis-cli -h ${_CT_NAME} -p ${S_CACHE_PORT} --latency-dist"

########################  PUBLISH

_echoT "------------------  publish ${_CT_NAME}"
lxc image list -f csv -c l | grep -q ^${_CT_NAME}$ && _eval lxc image alias rename ${_CT_NAME} ${_CT_NAME}-${_SDATE}
_eval lxc publish --force ${_CT_NAME} --alias ${_CT_NAME}

########################  END

_echoT "===================== ${_PART} end"
_partadd ${_PART} ${S_FILE_INSTALL_DONE}
