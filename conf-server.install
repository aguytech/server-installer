#!/bin/bash
#
# write by Aguy

_PART=conf-server
_echoT "==========================================  $_PART"

####################################  MAIN

_echoT "----------  release"

file="/etc/os-release"
! [ -f "${file}" ] && exit -e "${redb}error - unable to find file '$file'${cclear}"
# base
eval "$(grep '^VERSION_ID=' "${file}")" # define VERSION_ID
eval "$(grep '^ID=' "${file}")" # define VERSION_ID
S_RELEASE_ID="$ID"
S_RELEASE="${ID}${VERSION_ID}"
S_RELEASE_NAME=`sed -n "/^VERSION=/ s|.*(\(.*\)).*|\1|p" "${file}"`
S_RELEASE_NAME=${S_RELEASE_NAME% *}
if [ "$ID" = "manjaro" ]; then
	file="/etc/lsb-release"
	eval "$(grep '^DISTRIB_CODENAME=' "${file}")"
	S_RELEASE_NAME="$DISTRIB_CODENAME"
elif [ "$ID" = "alpine" ]; then
	S_RELEASE=${S_RELEASE%.*}
fi
S_RELEASE_NAME=${S_RELEASE_NAME,,}

for str in S_RELEASE S_RELEASE_ID S_RELEASE_NAME; do
	#sed -i "\|^${str}=| c ${str}=\"${!str}\"" "${S_GLOBAL_CONF}"
	_confset "${str}" "${!str}" "${S_GLOBAL_CONF}"
done


###################  PATH

_echoT "----------  conf S_PATH_INSTALL"

_confset "S_PATH_INSTALL" "${S_PATH_INSTALL}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_PATH_SAVE"

anstmp="${S_PATH_SAVE}" && _askno "path to save data (${anstmp})"
S_PATH_SAVE=${_ANSWER:-$anstmp} && _confset "S_PATH_SAVE" "${S_PATH_SAVE}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_PATH_LOG"

anstmp="${S_PATH_LOG}" && _askno "path to log data (${anstmp})"
S_PATH_LOG=${_ANSWER:-$anstmp} && _confset "S_PATH_LOG" "${S_PATH_LOG}" "${S_GLOBAL_CONF}"


paths="${S_PATH_SAVE} ${S_PATH_SAVE_BACKUP} ${S_PATH_LOG} ${S_PATH_LOG_SERVER} ${S_PATH_LOG_INSTALL}"
_echoT "----------  create ${paths}"

for path in $paths; do
	! [ -d "$path" ] && mkdir -p "$path"
done


###################  CLUSTER

_echoT "----------  create S_CLUSTER"

file=/etc/hosts
_keepcpts "${file}"
_echo "Here is the servers list actually declared ${!S_CLUSTER[*]}"
_askyn "If server missing, modify file '${S_GLOBAL_CONF}', before continue or valid to continue."

! grep -q "# ${S_DOMAIN_NAME} cluster" "${file}" && echo -e "\n# ${S_DOMAIN_NAME} cluster" >> "${file}"
for host in ${!S_CLUSTER[*]}; do
	eval ${S_CLUSTER[$host]}
	sed -i "/${ip}/d" "${file}"
	! grep -q "^${ip}" "${file}" && echo -e "${ip}\t${host}\t${name}" >> "${file}"
done
sed -i "s|^\(${_IPTHIS}.*\)$|#\1|" "${file}"

_echoT "----------  create save paths for cluster"

servers_list=${!S_CLUSTER[*]}
for host in ${servers_list/${HOSTNAME}/}; do
	! [ -d "${S_PATH_SAVE}/${host}" ] && mkdir "${S_PATH_SAVE}/${host}"
done


###################  SERVER

_echoT "----------  conf S_ETH"

S_ETH=`ip -4 -o route show to default|cut -d' ' -f5`
[ "$S_SERVER_TYPE" = "vz" ] && S_ETH='venet0:0' # for vz
_confset "S_ETH" "${S_ETH}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_SERVER_TYPE"

_menu "Select the server type for this server" home ovh docker kvm lxd
S_SERVER_TYPE=$_ANSWER && _confset "S_SERVER_TYPE" "${S_SERVER_TYPE}" "${S_GLOBAL_CONF}"


###################  HOSTING

if [[ " ovh home " = *" $S_SERVER_TYPE "* ]]; then

	_echoT "----------  conf S_HOSTING_TYPE"

	_menu "type of VM hosting" docker kvm lxd
	S_HOSTING_TYPE=$_ANSWER && _confset "S_HOSTING_TYPE" "${S_HOSTING_TYPE}" "${S_GLOBAL_CONF}"

	_echoT "----------  conf S_HOSTING_PATH"

	anstmp="${S_HOSTING_PATH}" && _askno "host pathroot for VM (${anstmp})"
	[ "${_ANSWER}" ] && S_HOSTING_PATH="${_ANSWER:-$anstmp}" && _confset "S_HOSTING_PATH" "${S_HOSTING_PATH}" "${S_GLOBAL_CONF}"

	_echoT "----------  conf S_HOSTING_PATH_SHARE"

	anstmp="${S_HOSTING_PATH_SHARE}" && _askno "host sharing path for VM (${anstmp})"
	[ "${_ANSWER}" ] && S_HOSTING_PATH_SHARE="${_ANSWER:-$anstmp}" && _confset "S_HOSTING_PATH_SHARE" "${S_HOSTING_PATH_SHARE}" "${S_GLOBAL_CONF}"

	_echoT "----------  conf S_HOSTING_PATH_LOG"

	anstmp="${S_HOSTING_PATH_LOG}" && _askno "host log path for VM for VM (${anstmp})"
	[ "${_ANSWER}" ] && S_HOSTING_PATH_LOG="${_ANSWER:-$anstmp}" && _confset "S_HOSTING_PATH_LOG" "${S_HOSTING_PATH_LOG}" "${S_GLOBAL_CONF}"

	_echoT "----------  conf S_HOSTING_PATH_SAVE"

	anstmp="${S_HOSTING_PATH_SAVE}" && _askno "host sharing path to save for VM (${anstmp})"
	[ "${_ANSWER}" ] && S_HOSTING_PATH_SAVE="${_ANSWER:-$anstmp}" && _confset "S_HOSTING_PATH_SAVE" "${S_HOSTING_PATH_SAVE}" "${S_GLOBAL_CONF}"


	paths="${S_HOSTING_PATH} ${S_HOSTING_PATH_SHARE}"
	_echoT "----------  create ${paths}"

	for path in $paths; do
		! [ -d "$path" ] && mkdir -p "$path"
	done


	###################  VM

	_echoT "----------  conf S_VM_DHCP_MIN"

	anstmp="${S_VM_DHCP_MIN}" && _askno "minimal IP for DHCP container (${anstmp})"
	S_VM_DHCP_MIN=${_ANSWER:-$anstmp} && _confset "S_VM_DHCP_MIN" "${S_VM_DHCP_MIN}" "${S_GLOBAL_CONF}"

	_echoT "----------  conf S_VM_DHCP_MAX"

	anstmp="${S_VM_DHCP_MAX}" && _askno "maximal IP for DHCP container (${anstmp})"
	S_VM_DHCP_MAX=${_ANSWER:-$anstmp} && _confset "S_VM_DHCP_MAX" "${S_VM_DHCP_MAX}" "${S_GLOBAL_CONF}"

	_echoT "----------  conf S_VM_ETH"

	_echo "Here is the network actually declared ${!S_VM_ETH[*]}"
	_askyn "You can modify this in file '${S_GLOBAL_CONF}', before continue or valid to continue."

	_echoT "----------  conf S_VM_PATH_SHARE"

	anstmp="${S_VM_PATH_SHARE}" && _askno "VM sharing path (${anstmp})"
	S_VM_PATH_SHARE=${_ANSWER:-$anstmp} && _confset "S_VM_PATH_SHARE" "${S_VM_PATH_SHARE}" "${S_GLOBAL_CONF}"

fi


###################  SERVICES

_echoT "----------  conf S_SERVICE_LOG"

anstmp="${S_SERVICE_LOG}" && _askno "service name for log (${anstmp})"
S_SERVICE_LOG=${_ANSWER:-$anstmp} && _confset "S_SERVICE_LOG" "${S_SERVICE_LOG}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_SERVICE_CACHE"

anstmp="${S_SERVICE_CACHE}" && _askno "service name for cache (${anstmp})"
S_SERVICE_CACHE=${_ANSWER:-$anstmp} && _confset "S_SERVICE_CACHE" "${S_SERVICE_CACHE}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_SERVICE_MAIL"

anstmp="${S_SERVICE_MAIL}" && _askno "service name for mail (${anstmp})"
S_SERVICE_MAIL=${_ANSWER:-$anstmp} && _confset "S_SERVICE_MAIL" "${S_SERVICE_MAIL}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_SERVICE_ADMIN"

anstmp="${S_SERVICE_ADMIN}" && _askno "service name for admin (${anstmp})"
S_SERVICE_ADMIN=${_ANSWER:-$anstmp} && _confset "S_SERVICE_ADMIN" "${S_SERVICE_ADMIN}" "${S_GLOBAL_CONF}"


###################  DOMAIN

_echoT "----------  conf S_DOMAIN_FQDN"

anstmp="${S_DOMAIN_FQDN}" && _askno "FQDN of principal domain (${anstmp})"
S_DOMAIN_FQDN=${_ANSWER:-$anstmp} && _confset "S_DOMAIN_FQDN" "${S_DOMAIN_FQDN}" "${S_GLOBAL_CONF}"
S_DOMAIN_NAME="${S_DOMAIN_FQDN%.*}" && _confset "S_DOMAIN_NAME" "${S_DOMAIN_NAME}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_DOMAIN_EMAIL_ADMIN"

anstmp="admin@$S_DOMAIN_FQDN" && _askno "Administration email of principal domain (${anstmp})"
S_DOMAIN_EMAIL_ADMIN="${_ANSWER:-$anstmp}" && _confset "S_DOMAIN_EMAIL_ADMIN" "${S_DOMAIN_EMAIL_ADMIN}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_DOMAIN_EMAIL_TECH"

anstmp="tech@$S_DOMAIN_FQDN" && _askno "Technical email of principal domain (${anstmp})"
S_DOMAIN_EMAIL_TECH="${_ANSWER:-$anstmp}" && _confset "S_DOMAIN_EMAIL_TECH" "${S_DOMAIN_EMAIL_TECH}" "${S_GLOBAL_CONF}"


####################################  NODE & IPS

_echoT "----------  conf S_IPS_ADMIN"

anstmp="${S_IPS_ADMIN}" && _askno "IPs of remote administrators (${anstmp})"
S_IPS_ADMIN=${_ANSWER:-$anstmp} && _confset "S_IPS_ADMIN" "${S_IPS_ADMIN}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_IPS_DEV"

anstmp="${S_IPS_DEV}" && _askno "IPs of remote developers (${anstmp})"
S_IPS_DEV=${_ANSWER:-$anstmp} && _confset "S_IPS_DEV" "${S_IPS_DEV}" "${S_GLOBAL_CONF}"


####################################  RSYSLOG

_echoT "----------  conf S_RSYSLOG_PTC"

_menu "Select the protocol to use for rsyslog centralisation" udp tcp
S_RSYSLOG_PTC=$_ANSWER && _confset "S_RSYSLOG_PTC" "${S_RSYSLOG_PTC}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_RSYSLOG_PORT"

anstmp="${S_RSYSLOG_PORT}" && _askno "Port to use for rsyslog (${anstmp})"
S_RSYSLOG_PORT=${_ANSWER:-$anstmp} && _confset "S_RSYSLOG_PORT" "${S_RSYSLOG_PORT}" "${S_GLOBAL_CONF}"


####################################  HAPROXY

_echoT "----------  conf S_HAPROXY_STATS_PORT"

anstmp="$S_HAPROXY_STATS_PORT" && _askno "port for haproxy statistics (${anstmp})"
S_HAPROXY_STATS_PORT=${_ANSWER:-$anstmp} && _confset "S_HAPROXY_STATS_PORT" "${S_HAPROXY_STATS_PORT}" "${S_GLOBAL_CONF}"


####################################  RSPAMD

_echoT "----------  conf S_RSPAMD_STATS_PORT"

anstmp="$S_RSPAMD_STATS_PORT" && _askno "port for rspamd statistics (${anstmp})"
S_RSPAMD_STATS_PORT=${_ANSWER:-$anstmp} && _confset "S_RSPAMD_STATS_PORT" "${S_RSPAMD_STATS_PORT}" "${S_GLOBAL_CONF}"


####################################  CACHE

_echoT "----------  conf S_CACHE_PORT"

anstmp="$S_CACHE_PORT" && _askno "port for redis connection (${anstmp})"
S_CACHE_PORT=${_ANSWER:-$anstmp} && _confset "S_CACHE_PORT" "${S_CACHE_PORT}" "${S_GLOBAL_CONF}"


####################################  DB

_echoT "----------  conf S_DB_USER_HTTP"

anstmp="$S_DB_USER_HTTP" && _askno "user for http acces to mariadb (${anstmp})"
S_DB_USER_HTTP=${_ANSWER:-$anstmp} && _confset "S_DB_USER_HTTP" "${S_DB_USER_HTTP}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_DB_USER_DEV"

anstmp="$S_DB_USER_DEV" && _askno "user for dev acces to mariadb (${anstmp})"
S_DB_USER_DEV=${_ANSWER:-$anstmp} && _confset "S_DB_USER_DEV" "${S_DB_USER_DEV}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_MARIA_PORT"

anstmp="$S_MARIA_PORT" && _askno "ports connections for mariaDB (${anstmp})"
S_MARIA_PORT=${_ANSWER:-$anstmp} && _confset "S_MARIA_PORT" "${S_MARIA_PORT}" "${S_GLOBAL_CONF}"


####################################  GLOBAL_CONF

_echoT "----------  source ${S_GLOBAL_CONF}"

. "${S_GLOBAL_CONF}"


####################################  GLOBAL_CONF

_echoT "----------  create global paths"

if [[ " docker kvm lxd vz " = *" ${S_SERVER_TYPE} "* ]]; then

	_echoT "----------  create shared paths for VMS"

	paths="${S_VM_PATH_SHARE} ${S_VM_PATH_SHARE_GLOBAL}"
	for path in $paths; do
		[ ! -d "$path" ] && mkdir -p "$path"
	done

	path="${S_VM_PATH_SHARE}"; chown root:root "$path" && chmod 777 "$path"
	path="${S_VM_PATH_SHARE_GLOBAL}"; chown root:root "$path" && chmod 770 "$path"
fi

####################################  END

_echoT "----------  end"
_eval "_partadd ${_PART} ${S_FILE_INSTALL_DONE}"
