#!/bin/bash
#
# write by Aguy

_PART=conf-server
_echoT "==========================================  ${_PART}"

####################################  MAIN

_echoT "----------  release"

file="/etc/os-release"
! [ -f "${file}" ] && exit -e "${redb}error - unable to find file '$file'${cclear}"
# base
eval "$(grep '^VERSION_ID=' "${file}")" # define VERSION_ID
eval "$(grep '^ID=' "${file}")" # define VERSION_ID
S_RELEASE_ID="$ID"
S_RELEASE="${ID}${VERSION_ID}"
S_RELEASE_NAME=`sed -n "/^VERSION=/ s|.*(\(.*\)).*|\1|p" "${file}"`
S_RELEASE_NAME=${S_RELEASE_NAME% *}
if [ "$ID" = "manjaro" ]; then
	file="/etc/lsb-release"
	eval "$(grep '^DISTRIB_CODENAME=' "${file}")"
	S_RELEASE_NAME="$DISTRIB_CODENAME"
elif [ "$ID" = "alpine" ]; then
	S_RELEASE=${S_RELEASE%.*}
fi
S_RELEASE_NAME=${S_RELEASE_NAME,,}

for str in S_RELEASE S_RELEASE_ID S_RELEASE_NAME; do
	#sed -i "\|^${str}=| c ${str}=\"${!str}\"" "${S_GLOBAL_CONF}"
	_confset "${str}" "${!str}" "${S_GLOBAL_CONF}"
done


###################  SERVER

_echoT "----------  conf S_ETH"

S_ETH=`ip -4 -o route show to default|cut -d' ' -f5`
[ "$S_SERVER_TYPE" = "vz" ] && S_ETH='venet0:0' # for vz
_confset "S_ETH" "${S_ETH}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_SERVER_TYPE"

_menu "Select the server type for this server" home ovh docker kvm lxd
S_SERVER_TYPE=${_ANSWER} && _confset "S_SERVER_TYPE" "${S_SERVER_TYPE}" "${S_GLOBAL_CONF}"


####################################  STORAGE

if [[ " ovh home " = *" $S_SERVER_TYPE "* ]]; then

	_echoT "----------  storage data"

	anstmp="zfs" && _menu "Select a driver for storage (${anstmp})" zfs btrfs
	S_STORAGE_DRIVER=${_ANSWER} && _confset "S_STORAGE_DRIVER" "${S_STORAGE_DRIVER}" "${S_GLOBAL_CONF}"

	blkid|grep -v squashfs && echo

	anstmp="/dev/sda5" && _askno "Give a device name for ROOT storage (${anstmp})" && S_STORAGE_ROOT=${_ANSWER:-${anstmp}} && _confset S_STORAGE_ROOT "${S_STORAGE_ROOT}" "${S_GLOBAL_CONF}"

fi


###################  PATH

_echoT "----------  conf S_PATH_INSTALL"

S_PATH_INSTALL=`dirname "$(readlink -e "${BASH_SOURCE[0]}")"`
S_PATH_INSTALL_CONF="${S_PATH_INSTALL}/conf"
S_PATH_INSTALL_XTRA="${S_PATH_INSTALL}/xtra"

_confset "S_PATH_INSTALL" "${S_PATH_INSTALL}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_PATH_SAVE"

anstmp="${S_PATH_SAVE}" && _askno "path to save data (${anstmp})"
S_PATH_SAVE=${_ANSWER:-${anstmp}} && _confset "S_PATH_SAVE" "${S_PATH_SAVE}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_PATH_BACKUP"

anstmp="${S_PATH_BACKUP}" && _askno "path to backup data (${anstmp})"
S_PATH_BACKUP=${_ANSWER:-${anstmp}} && _confset "S_PATH_BACKUP" "${S_PATH_BACKUP}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_PATH_LOG"

anstmp="${S_PATH_LOG}" && _askno "path to log data (${anstmp})"
S_PATH_LOG=${_ANSWER:-${anstmp}} && _confset "S_PATH_LOG" "${S_PATH_LOG}" "${S_GLOBAL_CONF}"


###################  CLUSTER

_echoT "----------  create S_CLUSTER"

file=/etc/hosts
_keepcpts "${file}"
_echo "Here is the servers list actually declared : ${!S_CLUSTER[*]}"
_askyn "If server missing, answer 'n', modify file '${S_GLOBAL_CONF}', and restart installation script"

! grep -q "# ${S_DOMAIN_NAME} cluster" "${file}" && echo -e "\n# ${S_DOMAIN_NAME} cluster" >> "${file}"
for host in ${!S_CLUSTER[*]}; do
	eval ${S_CLUSTER[$host]}
	sed -i "/${ip}/d" "${file}"
	! grep -q "^${ip}" "${file}" && echo -e "${ip}\t${host}\t${name}" >> "${file}"
done
sed -i "s|^\(${_IPTHIS}.*\)$|#\1|" "${file}"


###################  HOST

if [[ " ovh home " = *" $S_SERVER_TYPE "* ]]; then

	_echoT "----------  conf S_HOST_TYPE"

	_menu "type of VM hosting" lxd docker kvm
	S_HOST_TYPE=$_ANSWER && _confset "S_HOST_TYPE" "${S_HOST_TYPE}" "${S_GLOBAL_CONF}"

	_echoT "----------  conf S_HOST_PATH"

	anstmp="${S_HOST_PATH}" && _askno "host path for VM (${anstmp})"
	S_HOST_PATH="${_ANSWER:-${anstmp}}" && _confset "S_HOST_PATH" "${S_HOST_PATH}" "${S_GLOBAL_CONF}"

	_echoT "----------  conf S_HOST_PATH_SP"

	anstmp="${S_HOST_PATH_SP}" && _askno "host path to storage VM (${anstmp})"
	S_HOST_PATH_SP="${_ANSWER:-${anstmp}}" && _confset "S_HOST_PATH_SP" "${S_HOST_PATH_SP}" "${S_GLOBAL_CONF}"

	_echoT "----------  conf S_HOST_PATH_SHARE"

	anstmp="${S_HOST_PATH_SHARE}" && _askno "host path to VM sharing (${anstmp})"
	S_HOST_PATH_SHARE="${_ANSWER:-${anstmp}}" && _confset "S_HOST_PATH_SHARE" "${S_HOST_PATH_SHARE}" "${S_GLOBAL_CONF}"

	_echoT "----------  conf S_HOST_PATH_SAVE"

	anstmp="${S_HOST_PATH_SAVE}" && _askno "host path to VM saving (${anstmp})"
	S_HOST_PATH_SAVE="${_ANSWER:-${anstmp}}" && _confset "S_HOST_PATH_SAVE" "${S_HOST_PATH_SAVE}" "${S_GLOBAL_CONF}"

	_echoT "----------  conf S_HOST_PATH_LOG"

	anstmp="${S_HOST_PATH_LOG}" && _askno "host path to VM loging (${anstmp})"
	S_HOST_PATH_LOG="${_ANSWER:-${anstmp}}" && _confset "S_HOST_PATH_LOG" "${S_HOST_PATH_LOG}" "${S_GLOBAL_CONF}"


	_echoT "----------  conf S_HOST_VM_ETH"

	_echo "Here is the network actually declared : ${!S_HOST_VM_ETH[*]}"
	_askyn "If network are wrong, answer 'n', modify file '${S_GLOBAL_CONF}', and restart installation script"

	_echoT "----------  conf S_HOST_VM_SSH_NAT"

	anstmp="${S_HOST_VM_SSH_NAT}" && _askno "allow ssh connections from internet  directly to VMs, on to activate it (${anstmp})"
	[ "${_ANSWER}" ] && S_HOST_VM_SSH_NAT=${_ANSWER:-${anstmp}} && _confset "S_HOST_VM_SSH_NAT" "${S_HOST_VM_SSH_NAT}" "${S_GLOBAL_CONF}"

	_echoT "----------  conf S_HOST_DHCP_MIN"

	anstmp="${S_HOST_DHCP_MIN}" && _askno "minimal range IP for DHCP container (${anstmp})"
	S_HOST_DHCP_MIN=${_ANSWER:-${anstmp}} && _confset "S_HOST_DHCP_MIN" "${S_HOST_DHCP_MIN}" "${S_GLOBAL_CONF}"

	_echoT "----------  conf S_HOST_DHCP_MAX"

	anstmp="${S_HOST_DHCP_MAX}" && _askno "maximal range IP for DHCP container (${anstmp})"
	S_HOST_DHCP_MAX=${_ANSWER:-${anstmp}} && _confset "S_HOST_DHCP_MAX" "${S_HOST_DHCP_MAX}" "${S_GLOBAL_CONF}"

	_echoT "----------  conf S_HOST_PORT_PRE_SSH"

	anstmp=
	regexp='^[0-9]{1,3}$'
	while ! [[ ${anstmp} =~ $regexp ]]; do
	       anstmp="${S_HOST_PORT_PRE_SSH}"
	       _askno "Give the PREFIX of port for 'SSH' VMs connections S_HOST_PORT_PRE_SSH (${anstmp})"
	done
	S_HOST_PORT_PRE_SSH=${_ANSWER:-${anstmp}} && _confset "S_HOST_PORT_PRE_SSH" "${S_HOST_PORT_PRE_SSH}" "$S_GLOBAL_CONF"

	_echoT "----------  conf S_HOST_PORT_PRE_HTTP"

	anstmp=
	regexp="^[0-9]{1,3}$"
	while ! [[ ${anstmp} =~ $regexp ]]; do
	       anstmp="${S_HOST_PORT_PRE_HTTP}"
	       _askno "Give the PREFIX of port for 'HTTP' VMs connections S_HOST_PORT_PRE_HTTP (${anstmp})"
	done
	S_HOST_PORT_PRE_HTTP=${_ANSWER:-${anstmp}} && _confset "S_HOST_PORT_PRE_HTTP" "${S_HOST_PORT_PRE_HTTP}" "$S_GLOBAL_CONF"

	_echoT "----------  conf S_HOST_PORT_PRE_HTTPS"

	anstmp=
	regexp="^[0-9]{1,3}$"
	while ! [[ ${anstmp} =~ $regexp ]]; do
	       anstmp="${S_HOST_PORT_PRE_HTTPS}"
	       _askno "Give the PREFIX of port for 'HTTP SSL' VMs connections S_HOST_PORT_PRE_HTTPS (${anstmp})"
	done
	S_HOST_PORT_PRE_HTTPS=${_ANSWER:-${anstmp}} && _confset "S_HOST_PORT_PRE_HTTPS" "${S_HOST_PORT_PRE_HTTPS}" "$S_GLOBAL_CONF"

fi


###################  VM
S
_echoT "----------  conf S_VM_PATH_SHARE"

anstmp="${S_VM_PATH_SHARE}" && _askno "VM sharing path (${anstmp})"
S_VM_PATH_SHARE=${_ANSWER:-${anstmp}} && _confset "S_VM_PATH_SHARE" "${S_VM_PATH_SHARE}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_VM_PATH_SAVE"

anstmp="${S_VM_PATH_SAVE}" && _askno "VM saving path (${anstmp})"
S_VM_PATH_SAVE=${_ANSWER:-${anstmp}} && _confset "S_VM_PATH_SAVE" "${S_VM_PATH_SAVE}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_VM_PATH_BACKUP"

anstmp="${S_VM_PATH_BACKUP}" && _askno "VM backing up path (${anstmp})"
S_VM_PATH_BACKUP=${_ANSWER:-${anstmp}} && _confset "S_VM_PATH_BACKUP" "${S_VM_PATH_BACKUP}" "${S_GLOBAL_CONF}"


###################  SERVICES

declare -A S_SERVICE

_echoT "----------  conf S_SERVICE proxy"

anstmp="${S_SERVICE[proxy]}" && _askno "service name for proxy (${anstmp})"
[ "${_ANSWER}" ] && S_SERVICE[proxy]=${_ANSWER:-${anstmp}} && _confset_array "S_SERVICE" "proxy" "${S_SERVICE[proxy]}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_SERVICE log"

anstmp="${S_SERVICE[log]}" && _askno "service name to log (${anstmp})"
[ "${_ANSWER}" ] && S_SERVICE[log]=${_ANSWER:-${anstmp}} && _confset_array "S_SERVICE" "log" "${S_SERVICE[log]}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_SERVICE cache"

anstmp="${S_SERVICE[cache]}" && _askno "service name for cache (${anstmp})"
[ "${_ANSWER}" ] && S_SERVICE[cache]=${_ANSWER:-${anstmp}} && _confset_array "S_SERVICE" "cache" "${S_SERVICE[cache]}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_SERVICE mail"

anstmp="${S_SERVICE[mail]}" && _askno "service name for mail (${anstmp})"
[ "${_ANSWER}" ] && S_SERVICE[mail]=${_ANSWER:-${anstmp}} && _confset_array "S_SERVICE" "mail" "${S_SERVICE[mail]}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_SERVICE admin"

anstmp="${S_SERVICE[admin]}" && _askno "service name for admin (${anstmp})"
[ "${_ANSWER}" ] && S_SERVICE[admin]=${_ANSWER:-${anstmp}} && _confset_array "S_SERVICE" "admin" "${S_SERVICE[admin]}" "${S_GLOBAL_CONF}"


###################  DOMAIN

_echoT "----------  conf S_DOMAIN_FQDN"

anstmp="${S_DOMAIN_FQDN}" && _askno "FQDN of principal domain (${anstmp})"
S_DOMAIN_FQDN=${_ANSWER:-${anstmp}} && _confset "S_DOMAIN_FQDN" "${S_DOMAIN_FQDN}" "${S_GLOBAL_CONF}"
S_DOMAIN_NAME="${S_DOMAIN_FQDN%.*}" && _confset "S_DOMAIN_NAME" "${S_DOMAIN_NAME}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_DOMAIN_FQDN"

anstmp="${S_DOMAIN_FQDN%.*}" && _askno "Simple name of principal domain (${anstmp})"
S_DOMAIN_NAME=${_ANSWER:-${anstmp}} && _confset "S_DOMAIN_NAME" "${S_DOMAIN_NAME}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_DOMAIN_EMAIL_ADMIN"

anstmp="admin@$S_DOMAIN_FQDN" && _askno "Administration email of principal domain (${anstmp})"
S_DOMAIN_EMAIL_ADMIN="${_ANSWER:-${anstmp}}" && _confset "S_DOMAIN_EMAIL_ADMIN" "${S_DOMAIN_EMAIL_ADMIN}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_DOMAIN_EMAIL_TECH"

anstmp="tech@$S_DOMAIN_FQDN" && _askno "Technical email of principal domain (${anstmp})"
S_DOMAIN_EMAIL_TECH="${_ANSWER:-${anstmp}}" && _confset "S_DOMAIN_EMAIL_TECH" "${S_DOMAIN_EMAIL_TECH}" "${S_GLOBAL_CONF}"


####################################  USERS

_echoT "----------  conf S_IPS_ADMIN"

anstmp="${S_IPS_ADMIN}" && _askno "IPs of remote administrators (${anstmp})"
S_IPS_ADMIN=${_ANSWER:-${anstmp}} && _confset "S_IPS_ADMIN" "${S_IPS_ADMIN}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_IPS_DEV"

anstmp="${S_IPS_DEV}" && _askno "IPs of remote developers (${anstmp})"
S_IPS_DEV=${_ANSWER:-${anstmp}} && _confset "S_IPS_DEV" "${S_IPS_DEV}" "${S_GLOBAL_CONF}"


####################################  RSYSLOG

_echoT "----------  conf S_RSYSLOG_PTC"

anstmp="udp" && _menu "Select the protocol to use for rsyslog centralisation (${anstmp})" udp tcp
S_RSYSLOG_PTC=$_ANSWER && _confset "S_RSYSLOG_PTC" "${S_RSYSLOG_PTC}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_RSYSLOG_PORT"

anstmp="${S_RSYSLOG_PORT}" && _askno "Port to use for rsyslog (${anstmp})"
S_RSYSLOG_PORT=${_ANSWER:-${anstmp}} && _confset "S_RSYSLOG_PORT" "${S_RSYSLOG_PORT}" "${S_GLOBAL_CONF}"


####################################  HAPROXY

_echoT "----------  conf S_HAPROXY_STATS_PORT"

anstmp="$S_HAPROXY_STATS_PORT" && _askno "port for haproxy statistics (${anstmp})"
S_HAPROXY_STATS_PORT=${_ANSWER:-${anstmp}} && _confset "S_HAPROXY_STATS_PORT" "${S_HAPROXY_STATS_PORT}" "${S_GLOBAL_CONF}"


####################################  RSPAMD

_echoT "----------  conf S_RSPAMD_STATS_PORT"

anstmp="$S_RSPAMD_STATS_PORT" && _askno "port for rspamd statistics (${anstmp})"
S_RSPAMD_STATS_PORT=${_ANSWER:-${anstmp}} && _confset "S_RSPAMD_STATS_PORT" "${S_RSPAMD_STATS_PORT}" "${S_GLOBAL_CONF}"


####################################  CACHE

_echoT "----------  conf S_CACHE_PORT"

anstmp="$S_CACHE_PORT" && _askno "port for redis connection (${anstmp})"
S_CACHE_PORT=${_ANSWER:-${anstmp}} && _confset "S_CACHE_PORT" "${S_CACHE_PORT}" "${S_GLOBAL_CONF}"


####################################  DB

_echoT "----------  conf S_DB_USER_HTTP"

anstmp="$S_DB_USER_HTTP" && _askno "'http' user to acces to mariadb (${anstmp})"
S_DB_USER_HTTP=${_ANSWER:-${anstmp}} && _confset "S_DB_USER_HTTP" "${S_DB_USER_HTTP}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_DB_USER_DEV"

anstmp="$S_DB_USER_DEV" && _askno "'dev' user to acces to mariadb (${anstmp})"
S_DB_USER_DEV=${_ANSWER:-${anstmp}} && _confset "S_DB_USER_DEV" "${S_DB_USER_DEV}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_DB_MARIA_PORT"

anstmp="$S_DB_MARIA_PORT" && _askno "connections port for mariadb (${anstmp})"
S_DB_MARIA_PORT=${_ANSWER:-${anstmp}} && _confset "S_DB_MARIA_PORT" "${S_DB_MARIA_PORT}" "${S_GLOBAL_CONF}"

_echoT "----------  conf S_DB_PGSQL_PORT"

anstmp="$S_DB_PGSQL_PORT" && _askno "connections ports for rsddn2
postgre (${anstmp})"
S_DB_PGSQL_PORT=${_ANSWER:-${anstmp}} && _confset "S_DB_PGSQL_PORT" "${S_DB_PGSQL_PORT}" "${S_GLOBAL_CONF}"


####################################  ZFS

if [[ " ovh home " = *" $S_SERVER_TYPE "* ]]; then

	if [ "${S_STORAGE_DRIVER}" = "zfs" ]; then


		path="/zroot"
		_echoT "----------  zfs zpool ${path}"

		[ -d "${path}" ] && rm -fR "${path}"
		_evalq zpool create root "${S_STORAGE_ROOT}" -m "${path}"

		path="${S_PATH_SAVE}"
		_echoT "----------  zfs ${path}"

		[ -d "${path}" ] && rm -fR "${path}"
		_eval zfs create -o mountpoint="${path}" -o compression=lz4 root/save


		path="${S_HOST_PATH}"
		_echoT "----------  zfs ${path}"

		[ -d "${path}" ] && rm -fR "${path}"
		_eval zfs create -o mountpoint="${path}" -o compression=lz4 root/vm

		path="${S_HOST_PATH_SP}"
		_echoT "----------  zfs ${path}"

		[ -d "${path}" ] && rm -fR "${path}"
		_eval zfs create -o mountpoint="${path}" -o compression=lz4 root/vm/sp

		path="${S_HOST_PATH_SHARE}"
		_echoT "----------  zfs ${path}"

		[ -d "${path}" ] && rm -fR "${path}"
		_eval zfs create -o mountpoint="${path}" -o compression=lz4 root/vm/share
		_eval zfs set acltype=posixacl root/vm/share

		path="${S_HOST_PATH_SAVE}"
		_echoT "----------  zfs ${path}"

		[ -d "${path}" ] && rm -fR "${path}"
		_eval zfs create -o mountpoint="${path}" -o compression=lz4 root/vm/save


		_echoT "----------  zfs zpool list"

		zpool list -v

		_echoT "----------  zfs list"

		zfs list

	elif [ "${S_STORAGE_DRIVER}" = "btrfs" ]; then

		_echoT "----------  btrfs"

		_exite "You need to implemente this part"

		#storage="stock"
		#if ! [ "`lxc storage list -f json|jq -r '.[] | select(.name == "'${storage}'").name'`" ]; then
		#	[ "${S_STORAGE_DRIVER}" = btrfs ] && lxc storage create ${storage} ${S_STORAGE_DRIVER} source=/var/lib/lxd/storage-pools/stock
		#fi

	fi

fi


####################################  PATHS

paths="${S_PATH_SAVE} ${S_PATH_BACKUP} ${S_PATH_LOG} ${S_PATH_LOG_SERVER} ${S_PATH_LOG_INSTALL}"
_echoT "----------  create ${paths}"

for path in $paths; do
	! [ -d "$path" ] && mkdir -p "$path"
done

_echoT "----------  create save paths for cluster"

servers_list=${!S_CLUSTER[*]}
for host in ${servers_list/${HOSTNAME}/}; do
	! [ -d "${S_PATH_SAVE}/${host}" ] && mkdir "${S_PATH_SAVE}/${host}"
done

if [[ " ovh home " = *" $S_SERVER_TYPE "* ]]; then

	paths="${S_HOST_PATH} ${S_HOST_PATH_SHARE} ${S_HOST_PATH_LOG} ${S_HOST_PATH_SAVE}"
	_echoT "----------  create ${paths}"

	for path in $paths; do
		! [ -d "${path}" ] && mkdir -p "${path}"
	done
fi

if [[ " docker kvm lxd " = *" ${S_SERVER_TYPE} "* ]]; then

	_echoT "----------  create shared paths for VMS"

	paths="${S_VM_PATH_SHARE} ${S_VM_PATH_SAVE} ${S_VM_PATH_BACKUP}"
	for path in $paths; do
		[ ! -d "${path}" ] && mkdir -p "${path}"
	done
fi


####################################  END

_echoT "---------- ${_PART} end"
_eval "_partadd ${_PART} ${S_FILE_INSTALL_DONE}"
